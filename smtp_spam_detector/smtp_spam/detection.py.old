#!/usr/bin/env python3

# Full imports 
import pytrap
import sys
import time

# Import project files 
from smtp_spam import flow
from smtp_spam import cluster
from smtp_spam import entity

# Partial imports 
from difflib import SequenceMatcher
from pytrap import TrapCtx

# print current version of python
print (sys.version)

# Functions that compares two strings and decide their similarity according to
# SIMILARITY_INDEX, return true if they are similar otherwise false
def is_similar(server, cluster):
    #Server, list(Server)
    for s_flow in server.sent_history:
        for cluster_server in cluster:
            for c_flow in cluster_server.sent_history:
                if SequenceMatcher(None, s_flow.get_name(),
                                  c_flow.get_name()).ratio() > SIMILARITY_INDEX:
                    return True
    return False

# Takes list() of SMTP_ENTITYs and writes them as a csv file with '\n' sep.
def save_potencial_spam_machines(potencial_spammers):
    # Open file and start writing
    with open(PATH_P_SPAMMERS, 'w') as f:
        for ps in potencial_spammers:
            try:
                f.write(str(ps))
                f.write("\n")
            except:
                sys.stderr.write("Could not write to file!\n")
                return None
        f.close()
    print("Potencial spammers saved to: {0}").format(PATH_P_SPAMMERS)
    return 0

# data_pool is dictionary of servers with flow history as a list
def CDF(data_pool):
    CDF_dict = {}
    tr_l = []

    for server in data_pool:
        # Create a set for counting unqiue ips
        CDF_dict[data_pool[server].id] = set()
        for flow in data_pool[server].sent_history:
            CDF_dict[data_pool[server].id].add(flow)

        # Traffic ratio
        data_pool[server].set_up_traffic_ratio()
        tr_l.append(float(data_pool[server].traffic_ratio))

    # CDF for DST_IPs
    CDF_DST_IP_vals = []
    for i in CDF_dict:
        ln = len(CDF_dict[i])
        if ln > 0:
            CDF_DST_IP_vals.append(ln)

    with open(PATH_CDF_DST, 'w') as f:
        for val in CDF_DST_IP_vals:
            try:
                f.write(str(val))
                f.write(",")
            except:
                sys.stderr.write("Error while writing CDF report!\n")
                return None
        f.close()

    with open(PATH_CDF_TR, 'w') as f:
        for val in tr_l:
            try:
                f.write(str(val))
                f.write(',')
            except:
                sys.stderr.write("Error while writing CDF report!\n")
                return None
        f.close()

    return True

def main():
# Main loop ********************************************************************
# =========
    # Stores data about previous flows and saves them
    # to dictionary with SRC_IP as a key
    flow_pool = {}          # All mail traffic
    smtp_flow_pool = {}     # Only flows with smtp headers
    potencial_spammers = [] # List for potencial spammers

    cleanup_interval    = CLEAN_INTERVAL
    clustering_interval = CLUST_INTERVAL
    checked = 0
    alerts = 0

    # Timestamp flag
    TS_SET = 0

    # Inerval timestamps
    flow_first_ts = 0
    flow_curr_ts = 0

    analysis_ts = time.time()
    last_clustering = time.time()

    # Cluster for similiarity analysis
    cluster = Cluster()

    # Traplib init
    trap = pytrap.TrapCtx()
    trap.init(sys.argv, 1, 1)

    # Set the list of required fields in received messages.
    # This list is an output of e.g. flow_meter - basic flow.
    inputspec = ("ipaddr DST_IP,ipaddr SRC_IP,uint64 BYTES,uint64 LINK_BIT_FIELD," +
                "time TIME_FIRST,time TIME_LAST,uint32 PACKETS,uint32 SMTP_2XX_STAT_CODE_COUNT," +
                "uint32 SMTP_3XX_STAT_CODE_COUNT,uint32 SMTP_4XX_STAT_CODE_COUNT," +
                "uint32 SMTP_5XX_STAT_CODE_COUNT,uint32 SMTP_COMMAND_FLAGS," +
                "uint32 SMTP_MAIL_CMD_COUNT,uint32 SMTP_RCPT_CMD_COUNT," +
                "uint32 SMTP_STAT_CODE_FLAGS,uint16 DST_PORT,uint16 SRC_PORT," +
                "uint8 DIR_BIT_FIELD,uint8 PROTOCOL,uint8 TCP_FLAGS,uint8 TOS," +
                "uint8 TTL,string SMTP_DOMAIN,string SMTP_FIRST_RECIPIENT,string SMTP_FIRST_SENDER")
    trap.setRequiredFmt(0, pytrap.FMT_UNIREC, inputspec)
    rec = pytrap.UnirecTemplate(inputspec)

    # Define a template of alert (can be extended by any other field)
    alertspec = "ipaddr SRC_IP,time TIME_FIRST,time TIME_LAST,string SMTP_DOMAIN,string SMTP_FIRST_SENDER"
    alert = pytrap.UnirecTemplate(alertspec)
    # Set the data format to the output IFC
    trap.setDataFmt(0, pytrap.FMT_UNIREC, alertspec)

    # Allocate memory for the alert, we do not have any variable fields
    # so no argument is needed.
    #TODO:alert.createMessage()

    # Automat for smtp spam detection
    while (True):
        # Start analysis timer
        curr_time = time.time()

        flow_ts = 0 # A flow timestamp

        if flow_curr_ts + CLEAN_INTERVAL < flow_first_ts:
            # BASIC Analysis - no SMTP header is needed
            # Create timestamp of current statistics and create path for log
            data_report_time = time.time()
            data_report_path = PATH_STATS_REPORT + str(data_report_time)

            for server in flow_pool:
                flow_pool[server].report_statistics(data_report_path)
                # Add alert record to potencial spam pool for further analysis
                if (flow_pool[server].is_mail_server() is False):
                    potencial_spammers.append(server)

            print("Analysis runtime: {0}").format(data_report_time - analysis_ts)

            # Clear history
            flow_pool.clear()
            analysis_ts = curr_time

        else:
            # Recieve data from libtrap

            #TODO split flows here -> basic/smtp
            ctx = trap.getDataFmt()

            try:
                data = trap.recv()
            except pytrap.FormatChanged as e:
                fmttype, inputspec = trap.getDataFmt(0)
                rec = pytrap.UnirecTemplate(inputspec)
                adata = e.data

            if len(data) <= 1:
                break

            rec.setData(data)

            # Create a new flow record
            flow = SMTP_Flow(rec)

            if flow.BCP_Filter():
                alerts += 1

            # Update time timestamps
            if not TS_SET:
                flow_first_ts = flow.TIME_FIRST
                TS_SET = 1

            if flow.TIME_LAST > flow_curr_ts:
                flow_curr_ts = flow.TIME_LAST

            # Add it to the history flow datapool
            if flow.SRC_IP in flow_pool.keys():
                if flow.DST_IP in flow_pool.keys():
                    flow_pool[flow.DST_IP].incoming += 1
                else:
                    flow_pool[flow.DST_IP] = SMTP_ENTITY(flow.DST_IP)

                flow_pool[flow.SRC_IP].add_new_flow(flow)
                flow_pool[flow.SRC_IP].update_time(flow)

            else:
                flow_pool[flow.SRC_IP] = SMTP_ENTITY(flow)

            # Increment flow checked counter
            checked += 1

            # Print every 10k checked flows
            if checked % 10000 == 0:
                print('Flows in pool {0} | Checked {1}').format(len(flow_pool),
                                                                checked)

            # Similarity clustering
            # ! MIND THAT THIS IS NP-HARD PROBLEM ( Finding similiarity in
            # strings) thus demands huge computing power
            if last_clustering + clustering_interval < curr_time:
                cluster.clustering(flow_pool)
                last_clustering = time.time()

    # Free allocated TRAP IFCs
    trap.finalize()
    print("Flow scan report:")
    print("{0} suspicious in {1} flows").format(alerts, checked)
    print("Potencial spammers: {0}.\n").format(len(potencial_spammers))
    print(cluster)

    CDF(flow_pool)

    save_potencial_spam_machines(potencial_spammers)

if __name__ == "__main__":
    main()

