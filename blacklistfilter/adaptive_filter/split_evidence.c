/**
 * \file split_evidence.c
 * \brief Example of NEMEA module.
 * \author Tomas Cejka <cejkat@cesnet.cz>
 * \date 2019
 */
/*
 * Copyright (C) 2019 CESNET
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#define _GNU_SOURCE
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <getopt.h>
#include <libtrap/trap.h>
#include <unirec/unirec.h>
#include "fields.h"

trap_module_info_t *module_info = NULL;

/**
 * Definition of basic module information - module name, module description, number of input and output interfaces
 */
#define MODULE_BASIC_INFO(BASIC) \
  BASIC("split_evidence", \
        "The module saves flows into files with the name given by value of UniRec field." \
        "", 1, 0)

/**
 * Definition of module parameters - every parameter has short_opt, long_opt, description,
 * flag whether an argument is required or it is optional and argument type which is NULL
 * in case the parameter does not need argument.
 * Module parameter argument types: int8, int16, int32, int64, uint8, uint16, uint32, uint64, float, string
 */
#define MODULE_PARAMS(PARAM) \
  PARAM('f', "field", "UniRec field used for splitting.", required_argument, "string") \
  PARAM('p', "path", "Path to directory where to store files.", required_argument, "string")
  //PARAM(char, char *, char *, no_argument  or  required_argument, char *)

static int stop = 0;

/**
 * Function to handle SIGTERM and SIGINT signals (used to stop the module)
 */
TRAP_DEFAULT_SIGNAL_HANDLER(stop = 1)

struct hello_msg_header_s {
   uint8_t data_type;
   uint32_t data_fmt_spec_size;
} hello_msg_header;

const char *data_fmt_spec = NULL;
size_t data_fmt_spec_len = 0;

void write_into_file(const char *path, const void *in_rec, uint16_t in_rec_size, char *field_ptr, uint16_t key_size)
{
   struct stat stat_struct;
   FILE *f = NULL;
   char *name = NULL;

   if (asprintf(&name, "%s/%*s.trapcap", path, key_size, field_ptr) == -1) {
      return;
   }
   if (stat(name, &stat_struct) != 0) {
      f = fopen(name, "wb");
      fwrite(&hello_msg_header, sizeof(hello_msg_header), 1, f);
      fwrite(data_fmt_spec, data_fmt_spec_len, 1, f);
   } else {
      f = fopen(name, "ab");
   }
   free(name);

   uint32_t buffersize = htonl(in_rec_size + 2);
   uint16_t messagesize = htons(in_rec_size);

   while (fwrite(&buffersize, sizeof(buffersize), 1, f) != 1) { /* repeat */ }
   while (fwrite(&messagesize, sizeof(messagesize), 1, f) != 1) { /* repeat */ }
   while (fwrite(in_rec, in_rec_size, 1, f) != 1) { /* repeat */ }

   fclose(f);
}

int main(int argc, char **argv)
{
   int ret;
   signed char opt;
   ur_template_t *in_tmplt = NULL;
   const char *field_name = NULL;
   const char *output_path = NULL;

   /* **** TRAP initialization **** */

   INIT_MODULE_INFO_STRUCT(MODULE_BASIC_INFO, MODULE_PARAMS)

   /**
    * Let TRAP library parse program arguments, extract its parameters and initialize module interfaces
    */
   TRAP_DEFAULT_INITIALIZATION(argc, argv, *module_info);

   /**
    * Register signal handler.
    */
   TRAP_REGISTER_DEFAULT_SIGNAL_HANDLER();

   /**
    * Parse program arguments defined by MODULE_PARAMS macro with getopt() function (getopt_long() if available)
    * This macro is defined in config.h file generated by configure script
    */
   while ((opt = TRAP_GETOPT(argc, argv, module_getopt_string, long_options)) != -1) {
      switch (opt) {
      case 'f':
         field_name = optarg;
         break;
      case 'p':
         output_path = optarg;
         break;
      default:
         fprintf(stderr, "Invalid arguments.\n");
         FREE_MODULE_INFO_STRUCT(MODULE_BASIC_INFO, MODULE_PARAMS);
         TRAP_DEFAULT_FINALIZATION();
         return -1;
      }
   }

   if (field_name == NULL || output_path == NULL) {
      fprintf(stderr, "Error: missing required parameter -f or -p.\n");
      goto exit;
   }

   /* **** Create UniRec templates **** */

   trap_set_required_fmt(0, TRAP_FMT_UNIREC, "");

   /* **** Main processing loop **** */

   char *field_ptr = NULL;
   int field_id = UR_E_INVALID_NAME;
   // Read data from input, process them and write to output
   while (!stop) {
      const void *in_rec;
      uint16_t in_rec_size;

      // Receive data from input interface 0.
      // Block if data are not available immediately (unless a timeout is set using trap_ifcctl)
      ret = TRAP_RECEIVE(0, in_rec, in_rec_size, in_tmplt);
      // Handle possible errors
      TRAP_DEFAULT_RECV_ERROR_HANDLING(ret, continue, break);

      if (field_id == UR_E_INVALID_NAME) {
         /* first initialization of splitter key */
         field_id = ur_get_id_by_name(field_name);
         if (field_id == UR_E_INVALID_NAME) {
            fprintf(stderr, "Error: field %s was not found in the input template.\n", field_name);
            break;
         }
         if (trap_ctx_get_data_fmt(trap_get_global_ctx(), TRAPIFC_INPUT, 0, &hello_msg_header.data_type, &data_fmt_spec) != TRAP_E_OK) {
            fprintf(stderr, "Data format was not loaded.\n");\
         }
         data_fmt_spec_len = strlen(data_fmt_spec);
         hello_msg_header.data_fmt_spec_size = htonl(data_fmt_spec_len);
      }

      field_ptr = ur_get_ptr_by_id(in_tmplt, in_rec, field_id);

      // Check size of received data
      if (in_rec_size < ur_rec_fixlen_size(in_tmplt)) {
         if (in_rec_size <= 1) {
            break; // End of data (used for testing purposes)
         } else {
            fprintf(stderr, "Error: data with wrong size received (expected size: >= %hu, received size: %hu)\n",
                    ur_rec_fixlen_size(in_tmplt), in_rec_size);
            break;
         }
      }

      // PROCESS THE DATA
      write_into_file(output_path, in_rec, in_rec_size, field_ptr, ur_get_len(in_tmplt, in_rec, field_id));

   }

exit:
   /* **** Cleanup **** */

   // Do all necessary cleanup in libtrap before exiting
   TRAP_DEFAULT_FINALIZATION();

   // Release allocated memory for module_info structure
   FREE_MODULE_INFO_STRUCT(MODULE_BASIC_INFO, MODULE_PARAMS)

   // Free unirec template
   ur_free_template(in_tmplt);
   ur_finalize();

   return 0;
}

