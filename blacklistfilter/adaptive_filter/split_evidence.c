/**
 * \file split_evidence.c
 * \brief Example of NEMEA module.
 * \author Tomas Cejka <cejkat@cesnet.cz>
 * \date 2019
 */
/*
 * Copyright (C) 2019 CESNET
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#define _GNU_SOURCE
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <getopt.h>
#include <libtrap/trap.h>
#include <unirec/unirec.h>
#include <unirec/unirec2csv.h>
#include "fields.h"

trap_module_info_t *module_info = NULL;

/**
 * Definition of basic module information - module name, module description, number of input and output interfaces
 */
#define MODULE_BASIC_INFO(BASIC) \
  BASIC("split_evidence", \
        "The module saves flows into files with the name given by value of UniRec field." \
        "", 1, 0)

/**
 * Definition of module parameters - every parameter has short_opt, long_opt, description,
 * flag whether an argument is required or it is optional and argument type which is NULL
 * in case the parameter does not need argument.
 * Module parameter argument types: int8, int16, int32, int64, uint8, uint16, uint32, uint64, float, string
 */
#define MODULE_PARAMS(PARAM) \
  PARAM('f', "field", "UniRec field used for splitting.", required_argument, "string") \
  PARAM('p', "path", "Path to directory where to store files.", required_argument, "string")
  //PARAM(char, char *, char *, no_argument  or  required_argument, char *)

static int stop = 0;

/**
 * Function to handle SIGTERM and SIGINT signals (used to stop the module)
 */
TRAP_DEFAULT_SIGNAL_HANDLER(stop = 1)

urcsv_t *csv = NULL;
ur_template_t *in_tmplt = NULL;

/**
 * Write UniRec message into file (in CSV format)
 *
 * \param[in] path   Output directory
 * \param[in] in_rec Pointer to UniRec message
 * \param[in] key_str    Value of a key field that will be used in the name of file
 * \param[in] key_size   Size of the key field value (stored in key_str)
 */
void write_into_file(const char *path, const void *in_rec, char *key_str, uint16_t key_size)
{
   struct stat stat_struct;
   FILE *f = NULL;
   char *name = NULL;
   char *cl = NULL;

   if (asprintf(&name, "%s/%*s.csv", path, key_size, key_str) == -1) {
      return;
   }
   if (stat(name, &stat_struct) != 0) {
      f = fopen(name, "w");
      /* write header */
      cl = urcsv_header(csv);
      fprintf(f, "%s\n", cl);
      free(cl);
   } else {
      f = fopen(name, "a");
   }
   free(name);

   cl = urcsv_record(csv, in_rec);
   fprintf(f, "%s\n", cl);
   free(cl);

   fclose(f);
}

int main(int argc, char **argv)
{
   int ret;
   signed char opt;
   const char *field_name = NULL;
   const char *output_path = NULL;

   /* **** TRAP initialization **** */

   INIT_MODULE_INFO_STRUCT(MODULE_BASIC_INFO, MODULE_PARAMS)

   /**
    * Let TRAP library parse program arguments, extract its parameters and initialize module interfaces
    */
   TRAP_DEFAULT_INITIALIZATION(argc, argv, *module_info);

   /**
    * Register signal handler.
    */
   TRAP_REGISTER_DEFAULT_SIGNAL_HANDLER();

   /**
    * Parse program arguments defined by MODULE_PARAMS macro with getopt() function (getopt_long() if available)
    * This macro is defined in config.h file generated by configure script
    */
   while ((opt = TRAP_GETOPT(argc, argv, module_getopt_string, long_options)) != -1) {
      switch (opt) {
      case 'f':
         field_name = optarg;
         break;
      case 'p':
         output_path = optarg;
         break;
      default:
         fprintf(stderr, "Invalid arguments.\n");
         FREE_MODULE_INFO_STRUCT(MODULE_BASIC_INFO, MODULE_PARAMS);
         TRAP_DEFAULT_FINALIZATION();
         return -1;
      }
   }

   if (field_name == NULL || output_path == NULL) {
      fprintf(stderr, "Error: missing required parameter -f or -p.\n");
      goto exit;
   }

   /* **** Create UniRec templates **** */

   trap_set_required_fmt(0, TRAP_FMT_UNIREC, "");

   /* **** Main processing loop **** */

   int field_id = UR_E_INVALID_NAME;
   // Read data from input, process them and write to output
   while (!stop) {
      const void *in_rec;
      uint16_t in_rec_size;

      // Receive data from input interface 0.
      // Block if data are not available immediately (unless a timeout is set using trap_ifcctl)
      ret = TRAP_RECEIVE(0, in_rec, in_rec_size, in_tmplt);
      if (ret == TRAP_E_FORMAT_CHANGED) {
         free(csv);
         csv = urcsv_init(in_tmplt, ',');
         if (csv == NULL) {
            fprintf(stderr, "Failed to initialize UniRec2CSV converter.\n");
            break;
         }
      }
      // Handle possible errors
      TRAP_DEFAULT_RECV_ERROR_HANDLING(ret, continue, break);

      if (field_id == UR_E_INVALID_NAME) {
         /* first initialization of splitter key */
         field_id = ur_get_id_by_name(field_name);
         if (field_id == UR_E_INVALID_NAME) {
            fprintf(stderr, "Error: field %s was not found in the input template.\n", field_name);
            break;
         }
      }

      // Check size of received data
      if (in_rec_size < ur_rec_fixlen_size(in_tmplt)) {
         if (in_rec_size <= 1) {
            break; // End of data (used for testing purposes)
         } else {
            fprintf(stderr, "Error: data with wrong size received (expected size: >= %hu, received size: %hu)\n",
                    ur_rec_fixlen_size(in_tmplt), in_rec_size);
            break;
         }
      }

      char keystr[100];
      uint32_t keysize = urcsv_field(keystr, 99, in_rec, field_id, in_tmplt);
      keystr[keysize] = 0;

      char *r;
      while ((r = strchr(keystr, '/')) != NULL) {
         *r = '_';
      }
      if (keysize == 0) {
         strcpy(keystr, "UNKNOWN");
      }
      // PROCESS THE DATA
      write_into_file(output_path, in_rec, keystr, keysize);

   }

exit:
   /* **** Cleanup **** */

   // Do all necessary cleanup in libtrap before exiting
   TRAP_DEFAULT_FINALIZATION();

   // Release allocated memory for module_info structure
   FREE_MODULE_INFO_STRUCT(MODULE_BASIC_INFO, MODULE_PARAMS)

   // Free unirec template
   ur_free_template(in_tmplt);
   ur_finalize();

   return 0;
}

